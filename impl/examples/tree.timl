structure Tree = struct
open Basic
open List
       
datatype tree 'a : {Nat} =
         Leaf of tree 'a {0}
       | Node {n1 : Nat} {n2 : Nat} of 'a * tree 'a {n1} * tree 'a {n2} --> tree 'a {n1 + 1 + n2}

fun map_tree ['a 'b] {m : Time} (f : 'a -- m --> 'b) =
    let
      fun map {n : Nat} (tr : tree 'a {n}) return tree 'b {n} using (m + 3.0) * $n =
          case tr of
              Leaf => Leaf
            | Node (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end

absidx g : Fun 2 = fn m n => $(m + 3) * $n with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : tree 'a {n}) return tree 'b {n} using g m n =
          case tr of
              Leaf => Leaf
            | Node (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) = fn m n => $(m + 3) * $n with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : tree 'a {n}) return tree 'b {n} using g m n =
          case tr of
              Leaf => Leaf
            | Node (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun map_tree ['a 'b] {m : Nat} (f : 'a -- $m --> 'b) =
    let
      fun map {n : Nat} (tr : tree 'a {n}) return tree 'b {n} using g m n =
          case tr of
              Leaf => Leaf
            | Node (x, tr1, tr2) => Node (f x, map tr1, map tr2)
    in
      map
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun tree_foldmlr ['a 'b] {m : Nat} (f : 'a * 'b -- $m --> 'b) =
    let
      fun fold {n : Nat} acc (tr : tree 'a {n}) return 'b using g m n =
          case tr of
              Leaf => acc
            | Node (x, tr1, tr2) =>
              let
                val acc = f (x, acc)
                val acc = fold acc tr1
                val acc = fold acc tr2
              in
                acc
              end
    in
      fold
    end
end

absidx g : BigO 2 (fn m n => $m * $n) with
fun tree_foldrlm ['a 'b] {m : Nat} (f : 'a * 'b -- $m --> 'b) =
    let
      fun fold {n : Nat} acc (tr : tree 'a {n}) return 'b using g m n =
          case tr of
              Leaf => acc
            | Node (x, tr1, tr2) =>
              let
                val acc = fold acc tr2
                val acc = fold acc tr1
                val acc = f (x, acc)
              in
                acc
              end
    in
      fold
    end
end

absidx g : BigO 1 (fn n => $n) (* = fn n => $(4 * n) *) with
fun tree_append_rlm ['a] {n : Nat} (tr : tree 'a {n}) {n2 : Nat} (ls : list 'a {n2}) return list 'a {n + n2} using g n =
    case tr of
        Leaf => ls
      | Node (x (* : 'a *), tr1, tr2) =>
        let
          val ls = tree_append_rlm tr2 {_} ls
          val ls = tree_append_rlm tr1 {_} ls
          val ls = Cons (x, ls)
        in
          ls
        end
end

absidx g : BigO 1 (fn n => $n) with
fun tree_flatten_mlr (* ['a] *) {n : Nat} (tr : tree _ {n}) return list _ {n} using g n =
    tree_append_rlm tr {_} Nil
end

end
